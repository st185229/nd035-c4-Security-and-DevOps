= eCommerce Application Project Report

This project is the final implementation to demonstrate Scurity and DevOps skills that you learned in this lesson by completing an eCommerce application. A BCrypt encryption of password and JWT security based on https://auth0.com/blog/implementing-jwt-authentication-on-spring-boot/[auth0] is implemented.

. Unit testing with coverage
. Using Git practices such as .gitignore &amp; branching
. Unit testing with a specific amount of coverage
. Logging
. Interpretation of logging with Splunk
. CI & CD with Jenkins

== Changes to the Project Template

The original template is written in Java using Spring Boot, Hibernate ORM, and the H2 database. H2 is an in memory database, so if you need to retry something, every application startup is a fresh copy.

* Instead of continue using outdated(still commercially supported) Java 8, the project has been upgraded to java 11
* Replaced the springboot started logging with log4j2. Instead of using sl4j wrapper, the log4J provides its own APIs
* Swagger has been added , whitelisted the URL - http://localhost:9999/udacity/swagger-ui.html#/ so that it can be accessed
* https://www.eclemma.org/jacoco/[jacoco] has been added to Junit test coverage reporting
* https://fabric8.io/[Fabric8]'s docker maven https://github.com/fabric8io/docker-maven-plugin[plugin] has been added to create container image as well as run the containers in the Jenkins CD

The code has been refactored to add a service layer . So Once the project is set up, you will see 5 packages:

* demo - this package contains the main method which runs the application

* model.persistence - this package contains the data models that Hibernate persists to H2. There are 4 models: Cart, for holding a User's items; Item , for defining new items; User, to hold user account information; and UserOrder, to hold information about submitted orders. Looking back at the application “demo” class, you'll see the `@EntityScan` annotation, telling Spring that this package contains our data models

* model.persistence.repositories - these contain a `JpaRepository` interface for each of our models. This allows Hibernate to connect them with our database so we can access data in the code, as well as define certain convenience methods. Look through them and see the methods that have been declared. Looking at the application “demo” class, you’ll see the `@EnableJpaRepositories` annotation, telling Spring that this package contains our data repositories.

* model.requests - this package contains the request models. The request models will be transformed by Jackson from JSON to these models as requests are made. Note the `Json` annotations, telling Jackson to include and ignore certain fields of the requests. You can also see these annotations on the models themselves.

* controllers - these contain the api endpoints for our app, 1 per model. Note they all have the `@RestController` annotation to allow Spring to understand that they are a part of a REST API

* *_New_*  openapi  This is where swagger.io configurations are stored

* Security

The security has 4 classes

|===
|No |Class Name |Purpose

|1
|JWTAuthenticationFilter
|This  is an implementation of UsernamePasswordAuthenticationFilter. This authenticates the users including all pre and post authentication tasks

|2
|JWTAuthorizationFilter
|This class implements filter chains which query for JWT  token in the header (Bearer). This also checks whether the subject of the token actually represents the user

|3
|WebSecurityConfig
|Its an implementation of WebSecurityConfigurerAdapter configure login
|===


In resources, you'll see the application configuration that sets up our database and Hibernate, It also contains a data.sql file with a couple of items to populate the database with. Spring will run this file every time the application starts


http://localhost:8080/api/user/create with an example body like 

----
{
    "username": "usertest",
    "password" : "pass12345678",
    "confirmPassword": "pass12345678"
}

----

and this would return

----
{
    "id": 2,
    "username": "usertest"
}
----

== Access restricted and allowed endpoints
=== Allowed
==== Login
----
POST /login 
{
    "username": "test",
    "password": "somepassword"
}
----
----
GET http://localhost:8080/api
----
----
GET http://localhost:8080/api/item/
----
----
GET http://localhost:8080/api/item/1
----
Others related to swaggar
----
/v2/api-docs",
"/configuration/ui",
"/swagger-ui.html"
----

and that should, if those are valid credentials, return a 200 OK with an Authorization header which looks like "Bearer <data>" this "Bearer <data>" is a JWT and must be sent as a Authorization header for all other rqeuests. If it's not present, endpoints should return 401 Unauthorized. If it's present and valid, the endpoints should function as normal.

== Testing

There are 21 test cases been created to assure 92% coverage
image::splunk_reports/Coverage-unit test.png[alt="Coverage"]
This has been organised under a test suit . Can be executed to through maven goals such _test_ , _verify_ etc
image::splunk_reports/unit-test-execution.png[alt="test execution"]

=== Docker
A maven plugin https://github.com/fabric8io/docker-maven-plugin[fabric8] is used to create and run docker images
----
<groupId>io.fabric8</groupId>
<artifactId>docker-maven-plugin</artifactId>
----
See the POM file for details.
The dockerfile is below
----
# we are extending everything from tomcat:9.0 image ...
FROM tomcat:9.0.43-jdk11-openjdk
MAINTAINER Suresh Thomas
EXPOSE 8080
# COPY path-to-your-application-war path-to-webapps-in-docker-tomcat
ADD target/${project.artifactId}.war /usr/local/tomcat/webapps/udacity.war
CMD ["catalina.sh","run"]
----
==== Build the docker file from Maven
----
mvn docker:build
----
==== Run the docker file

docker run -p 9999:8080 auth-course:0.0.1.0

